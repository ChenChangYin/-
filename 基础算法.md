## 基础算法

### 1.素数判断(暴力, 素数筛,线性筛,求约数个数,求约数和)

**1.素数是什么样的呢?**

**答:简单地说就是除了1和他本身不能被其他数整除的数(如2, 3, 5, 7, 11, 13)**

**暴力法:利用循环判断有没有可以整除n的数,直到循环到n-1,如若没有一个数可以整除n则n为素数,否则n为合数**

**上代码**

```c
#include <stdio.h>

int is_prime(int n) {
    if (n <= 1) return 0;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return 0;
    }
    return 1;
}

int main() {
    int n;
    while(scanf("%d", &n) != EOF) {
        if (!is_prime(n)) printf("NO\n");
        else printf("YES\n");
    }
    return 0;
}
```

**素数筛:素数筛的思想就是从2开始将其倍数全部筛掉,然后在筛掉3的倍数,判断n是否被筛,没被筛的话筛n的倍数,筛过的话n加1.    (简单地说就是,用素数n筛掉n的倍数,因为n的倍数一定是合数)**

**取30个数模拟一下素数筛的过程**

**上代码**

```c
#include <stdio.h>
#define max 1000

int prime[max + 5] = {0};


void init() {
    prime[0] = prime[1] = 1;
    for (int i = 2; i * i < max; i++) {
        if (prime[i]) continue;
        for (int j = 2 * i; j <= max; j += i) {
            prime[j] = 1;
        }
    }
    return ;
}
int main() {
    init();
    int n;
    while(scanf("%d", &n) != EOF) {
        if (n <= max && prime[n] == 0) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
```

**练习题:我输入一个10000以内的数字n, 要求输出n的最大素因子**

```c
#include <stdio.h>
#define max 1000

int prime[max + 5] = {0};


void init() {
    prime[0] = prime[1] = 1;
    for (int i = 2; i < max; i++) {
        if (!prime[i])
            for (int j = i; j <= max; j += i) {
                prime[j] = i;
            }
    }
    return ;
}
int main() {
    init();
    int n;
    while(scanf("%d", &n) != EOF) {
        printf("%d\n", prime[n]);
    }
    return 0;
}
```



**练习题:我输入一个10000以内的数字n, 要求输出n的最小素因子**

```c
#include <stdio.h>
#define max 1000

int prime[max + 5] = {0};


void init() {
    prime[0] = prime[1] = 1;
    for (int i = 2; i < max; i++) {
        if (!prime[i])
            for (int j = i; j <= max; j += i) {
                if (!prime[j])
                    prime[j] = i;
            }
    }
    return ;
}
int main() {
    init();
    int n;
    while(scanf("%d", &n) != EOF) {
        printf("%d\n", prime[n]);
    }
    return 0;
}
```



**看似素数筛很不错, 但是6被2, 3都标记过,一共标记过2次, 会不会觉得有些浪费时间呢?**

**3.线性筛:线性筛就不会重复标记那些数字了,**

**一个合数N可以写成一个素数m与合数(或素数)n的乘积N = m * n**

**例如12 = 2 * 6 **

**12 = 3 * 4**

**这个12我们让他只会被6标记(也就是用最大的因子去标记N)**

**每遇到一个素数m都会将m存进数组**

**练习一下:取30个数模拟一下线性筛的过程**

```c
#include <stdio.h>
#define max 1000

int prime[max + 5] = {0};
int add[max + 5] = {0};

void init() {
    add[0] = add[1] = 1;
    for (int i = 2; i <= max; i++) {
        if (!add[i]) prime[++prime[0]] = i;
        for (int j = 1; j <= prime[0]; j++) {
            if (prime[j] * i > max) break;
            add[prime[j] * i] = 1;
            if (i % prime[j] == 0) break;
        }
    }
    return ;
}
int main() {
    init();
    int n;
    while (scanf("%d", &n) != EOF) {
        if (add[n]) printf("NO\n");
        else printf("YES\n");
    }
    return 0;
}
```

**求约数个数: 求约数个数思考以下几个问题**

**1. 12的约数都有谁？(1, 2, 3, 4, 6,12) 6个**

**2.  3的约数都有谁？(1, 3) 2个**

**3. 4的约数都有谁？(1, 2, 4) 3个**

**也就是说12的约数个数等于 3的约数个数 乘以 4的约数个数(推测)**

**F(N) = F(M) * F(n)     若 N = M * n (一定对么？)**

**2 (1, 2)  2个 6(1, 2, 3, 6)  4个 显然此时F(N) != F(M) * F(n)**



**4.**



### 2.高精度,加减乘除混合

### 3.二分,三分(花式二分,三分)

